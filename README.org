#+TITLE: Unix in Lisp - mount Unix into Common Lisp image
Unix in Lisp is currently a usable Lisp (not POSIX!) shell for Unix. The distinctive feature of Unix in Lisp is that rather than creating a sub-language for Unix operations, Unix concepts are directly/shallowly embedded into Lisp (e.g. Unix commands become Lisp macros).
* Table of Contents :TOC:
- [[#quick-start][Quick Start]]
  - [[#examples][Examples]]
- [[#documentation][Documentation]]
  - [[#file-system-mapping][File System Mapping]]
  - [[#command-and-process-mapping][Command and Process Mapping]]
  - [[#environment][Environment]]
  - [[#scripting-blazingly-fast-start-up][Scripting (blazingly fast start up)]]

* Quick Start
Currently, only SBCL is tested. Clone this repository into your =~/quicklisp/local-projects/=. You may also need to clone [[https://github.com/kchanqvq/native-lazyseq]] into =~/quicklisp/local-projects/=.

It's recommended to load ~unix-in-slime.el~ for better Slime integration. To load it, ~M-x load-file~ in Emacs then select ~unix-in-slime.el~, then ~M-x unix-in-slime~ to start a new REPL.

~unix-in-slime~ installs hacks to the host Lisp environment by calling ~(unix-in-lisp:install)~ on startup. To undo hacks done to the host environment (currently mostly the reader and printer, for the Unix style slash syntax) and unmount Unix FS packages, run ~(unix-in-lisp:uninstall)~.

** Examples
(Some print-outs are omitted)

Counting number of files
#+begin_src 
  /Users/kchan> (cd quicklisp/local-projects/unix-in-lisp)
  /Users/kchan/quicklisp/local-projects/unix-in-lisp> (pipe (wc -l) (ls))
         9
#+end_src
But why not the Lisp way as well!
#+begin_src 
  /Users/kchan/quicklisp/local-projects/unix-in-lisp> (length (serapeum:package-exports))
  9
#+end_src

For more examples, see [[file:TUTORIAL.org]]
* Documentation
** File System Mapping
Directories are mapped as /Unix FS packages/. A Unix FS packages is any Common Lisp package whose package name designate an absolute path name (as in ~uiop:absolute-pathname-p~, or usually, when it starts with a slash).

The exported symbols of a Unix FS package should one-to-one correspond to files in the mapped directory. Exceptions to this one-to-one correspondence:
- Because of the limit of file system change tracking, the package structure in the Common Lisp image may diverge from the Unix FS state.
  - Currently, the state of a Unix FS package is synchronized when calling ~mount-directory~. By default, ~remount-current-directory~ is added to ~*post-command-hook*~, which does the obvious thing.

** Command and Process Mapping
Unix in Lisp manages jobs in the unit of /Effective processes/. Theses include regular Unix processes represented by ~simple-process~, and ~pipeline~'s which are consisted of any number of UNIX processes and Lisp function stages.
*** Simple commands
When Unix in Lisp maps a directory, files are checked for execution permission and executable ones are mapped as Common Lisp macros.  These macros /implicitly quasiquotes/ their arguments. The arguments are converted to strings using ~to-argument~, then passed to the corresponding executable.

Examples of using macros mapped from Unix commands
#+begin_src
  /Users/kchan/some-documents> (cat ,@(ls))
  ;; This cats together all files under current directory.
#+end_src

When ~to-argument~ sees a list, it converts its elements recursively and then concatenate them together. Hopefully it makes (manually or programmatically) writing structured command arguments easier

#+begin_src
  /Users/kchan/some-repo> (configure (--prefix= ,*my-prefered-prefix*))
  ;; Similar to posix shell: configure --prefix=$MY-PREFERED-PREFIX
#+end_src

You can also set up redirections (and maybe other process creation settings in the future) via supplying keyword arguments. These arguments /are not/ implicitly quasiquoted and /are/ evaluated.

#+begin_src
  /Users/kchan/some-documents> (ls :output *terminal-io*)
  ;; This outputs to *terminal-io*, which usually goes into *inferior-lisp* buffer.
#+end_src

#+begin_src
  /Users/kchan/some-documents> (ls :error :output)
  ;; This redirect stderr of ls command to its stdout, like 2>&1 in posix shell
#+end_src

Like you have discovered in ~(cat ,@(ls))~, effective processes can be used like Lisp sequences -- they designate the sequence of their output lines.
*** Pipeline

Pipelines are created via the ~pipe~ macro:
#+begin_src
  /Users/kchan/quicklisp/local-projects/unix-in-lisp> (pipe (wc -l) (ls))
         9
#+end_src

Under the hood, except the first stage, each stage of the pipeline is passed ~:input <result-of-previous-pipeline-stage>~ as an additional argument. Alternatively, if there are arguments ~_~, they are substituted with the result of the previous stage. You can mix Lisp functions and values with Unix commands. Using Lisp value as the first input stage is easy enough:
#+begin_src
  /Users/kchan> (pipe (iota 10) (wc))
        10      10      20
#+end_src

The ~_~ extension make it easy to add Lisp functions to the mix:
#+begin_src
  /Users/kchan> (pipe (ls) (filter (lambda (s) (> (length s) 10)) _) (wc -l))
        47
#+end_src
The above counts the number of file with filename longer than 10 under my home directory.
*** Interactive Use
Inside a ~unix-in-slime~ listener, if the primary value of evaluation is an effective process, ~unix-in-slime~ automatically "connect" it to the listener, i.e. I/O of the listener is redirected to the process, similar to /foreground processes/ in POSIX shell:
#+begin_src
/Users/kchan> (python3 -i)
Python 3.8.9 (default, Apr 13 2022, 08:48:07)
[Clang 13.1.6 (clang-1316.0.21.2.5)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello world!")
Hello world!
>>> ; No values
/Users/kchan>
#+end_src

*Attention:* use ~C-u RET~ to signal EOF in ~unix-in-slime~, similar to ~Ctrl+D~ in POSIX shells. You can interrupt evaluation via ~C-c C-c~ like usual, after which you will be provided a few restarts:
1. ~BACKGROUND~ puts the job in background (accessible via ~unix-in-lisp:*jobs*~)
2. ~ABORT~ terminates the current job (via ~SIGTERM~ for Unix processes)

*Attention:* You have to use ~-i~ flag to start Python REPL, because Unix in Lisp currently talk to all processes using pipe rather than pseudo tty. Without ~-i~, Python will start itself into non-interactive mode. Other REPLs may need respective flags.

When using Unix in Lisp outside ~unix-in-slime~, use ~(unix-in-lisp:repl-connect <process>)~ to achieve the same thing.

~unix-in-lisp:*jobs*~ keeps a list of running effective processes:
#+begin_src
unix-in-lisp> *jobs*
(#<simple-process python3 (running) {1005BFFCF3}>)
#+end_src
Note that because ~unix-in-slime~ listener connects a job automatically if it is the primary value of evaluation, you can use e.g.
#+begin_src
unix-in-lisp> (nth 0 *jobs*)
#+end_src
to resume from a background job.
** Environment
Unix environment variables are mapped to special (dynamic-scope) Lisp variables.
#+begin_src
/Users/kchan> $logname
"kchan"
#+end_src

You can set them or dynamically bind them
#+begin_src
/Users/kchan> (setf $test "42")
"42"
/Users/kchan> (pipe '("echo $TEST") (bash))
42
nil
/Users/kchan> (let (($test "override")) (pipe '("echo $TEST") (bash)))
override
nil
#+end_src

The above works with the help of a reader macro defined on ~$~, which registers the following symbol as an environment variable. If you want to use Unix in Lisp environment variables without our readtable, you need to use function ~unix-in-lisp:ensure-env-var~ to register the symbol first. Consult its docstring for more information.

Unix in Lisp keeps its own idea of a Unix environment, and pass to subprocesses created by it (e.g. via the macros it created from Unix commands). Other Lisp facilities (e.g. ~uiop:run-program~) does not know this, and usually inherit the "real" Unix environment of the Lisp process instead. To remedy this, Unix in Lisp provides function ~unix-in-lisp:synchronize-env-to-unix~ which copies the environment Unix in Lisp manages to the "real" Unix environment of the Lisp process. This is by default run in ~*post-command-hook*~, and you may want to call them before using other Lisp facilities that spawns Unix subprocesses.
** Scripting (blazingly fast start up)
The recommended way to write scripts is to create executable files (say ~do-stuff.sh~) with contents like
#+begin_src
#!/usr/env/bin sbcl --script
(asdf:require-system "<dependency>")
(asdf:require-system "unix-in-lisp")
(unix-in-lisp:setup)
<do-stuff>
#+end_src

The benefit of the above approach is that it is blazingly fast when started from within Unix in Lisp (via e.g. ~(do-stuff.sh)~), because Unix in Lisp has a /Fast loading command/ mechanism, which can execute the script within Unix in Lisp image without starting subprocess if it detects a Lisp shebang. The essence of writing fast startup script is:
1. Use ~#!/usr/env/bin sbcl --script~ shebang. Currently it has to be an exact match.
2. Use ~asdf:require-system~. This avoids scanning the ASDF registry directory tree for modification, which wastes significant time!

On my machine, a hello world using the above approach run in 0.5ms, while Python 3 uses 30ms!
