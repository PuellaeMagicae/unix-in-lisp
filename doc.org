* File System Mapping
Directories are mapped as /Unix  FS packages/. Unix FS packages is any Common Lisp package whose package name designate an absolute pathname (as in ~uiop:absolute-pathname-p~).

The exported symbols of a Unix FS package should one-to-one correspond to files in the mapped directory. Exceptions to this one-to-one correspondence:
- When using ~directory/file~ to access a non-existent ~file~, the symbol ~file~ is interned and exported for ~directory~ rather than signaling an error. This is to work better with commands expecting a non-existent path, e.g. ~mv directory/existent-file directory/not-yet-existent-file~.
- Because of the limit of file system change tracking, the package structure in the Common Lisp image may diverge from the Unix FS state.
  - Currently, the state of a Unix FS package is synchronized when calling ~mount-directory~. By default, ~remount-current-directory~ is added to ~*post-command-hook*~, which does the obvious thing.

The reader treats Unix FS packages similar to the ~keyword~ package. Symbols interned in Unix FS packages are by default /self-evaluating/. This make it possible to write filenames and command arguments without quotes. There's no problem setting the value of an internal symbol and use it as a variable. However, the exported symbols of a Unix FS packages, which represents files, should always be self-evaluating. If an exported symbol is found to have a value other than itself (this may happen when a new file is created and the corresponding symbol is exported), a condition is raised.

*Discussion.* Is this really the right way? It seems more sensible to only automatically make /some/ symbols self-evaluating, e.g. those beginning with a ~-~, otherwise there's too much clash with regular usage of symbols as variables. However, user also need a convenient way to refer to non-existent files under /current/ directory. This is not addressed by the above auto-exporting mechanism.

* Command and Process Mapping
/Effective processes/ are represented by instance of ~pipeline~ class. Effective processes include regular Unix processes, and pipeline made from several processes.

~pipeline~ are valid ~chanl~ channels. You can call ~send~ and ~recv~ on them. These methods accept an additional  ~:format~ argument, comparing to those for native ~chanl~ channels, which specify the granularity of the messages. By default, ~:line~ is used.

When Unix in Lisp maps a directory, files are checked for execution permission and executable ones are mapped as Common Lisp functions. These functions process their arguments using ~to-argument~ before pass to the corresponding executable, with one exception: If the last argument is an effective process, the current process being created  is chained after the effective process via Unix pipes. The combined effective process is returned.
